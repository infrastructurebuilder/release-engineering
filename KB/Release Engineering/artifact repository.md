
# Artifact Repository

## Definition
An artifact repository is an [[environment]] that has been specifically configured to store, manage, and distribute [[artifact|artifacts]].  The [[platform]] that the environment is based on is determined by the type and scale of the desired repository.

## Examples

Some examples of artifact repositories are:

- Sonatype's Nexus (General Purpose)
- JFrog's Artifactory (General Purpose)
- PyPI (Python packages)
- Docker Hub (Docker containers)
- Elastic Container Registry on AWS (Docker containers)
- npm.org (NPM packages)

## Bad Examples

Some rudimentary storage locations, which might be used in a pinch, are:

- Azure Artifacts - this artifact repository is, as of the time of this writing, severely limited in it's capabilities
- GitHub Releases - a per-repository file storage mechanism, but convenient if a given team only produces a very small number of artifacts (i.e. one or two)
- Jenkins' internal artifact store - entirely transient but useful during a Jenkins build
- GitHub source repositories, using Tags - this is effectively what constitutes a [[tag release]].  It is also the default mechanism for some parts of some languages (notably `golang` libraries).

### Why Tag Releases Are Problematic
Tag releases tend to have negative effects and/or side effects that can be difficult to detect or deal with.  Notably, a tag release of a repository that one does not completely control ___cannot ever be considered truly immutable___.  Being under the control of someone outside the organization, that person can change the contents of a tag and the underlying systems will [probably] notice, but will [probably] not complain.  It is _possible_ to determine that a tag release has not been mutated, but it certainly is neither automatic or convenient to do so.

One (painful) way to deal with this is to fork such a repository and only pull in changes on a "per-tagging event" basis. This is very tedious and likely not worth the effort.  

## Uses of an Artifact Repository

An artifact repository is designed to be the [ostensibly] durable storage location of [[artifact]] instances for use by some target [[audience]]. The presence of an [[artifact]] in such a repository often indicates that some degree of [[gatekeeping]] was performed on the [[build]].  Depending on the [[platform|platforms]] involved, sometimes this gatekeeping is "none", but the quality of the retained artifact is highly dependent on this.

Typically, a build would store built artifacts into a "hosted" artifact repository as a final step of the build.  This implies that the artifact then has some [[version|named identifier]] that uniquely indicates the stored artifact.  This identifier can then be used later to retrieve the artifact, generally for use in some other process.

### Hosted
Hosted repositories hold artifacts that are specific to, and usually generated by, the owner of the artifact repository.  They are usually not shared outside of the owner's group and/or business, and are generally managed with role-based access.

Hosted repositories are usually of two types -- mutable and immutable.  The effective difference is that a mutable repository can have specific [[version]]s of [[artifact]]s overwritten, whereas an immutable repository is effectively "write-once" for a given [[version]].  These are sometimes called "Snapshot" and "Release" repositories, respectively.

#### Release
Release repositories are meant to be immutable.  Once a release is performed, that release may not be performed again and any attempt to redeply it will usually result in a `403` (forbidden) error.  Within [[InfrastructureBuilder]], release repositories only contain [[release]]d [[artifact]]s.  The artifact repository itself is what prevents redeployment of any [[version]] of an existing artifact in accordance with sane [[release engineering]] principles.

A caveat to the release repository mechanism is that a committment is required to ensure that no one should ever delete an old [[release]], even it is labled "bad" or "errored".  This allows previous [[deployment]]s of unsatisfactory code to be redone, certainly, but sometimes those are necessary.  It also prevents anyone from "spoofing" a previous release.

#### Snapshot
Snapshot repos only contain pre-[[release]] [[artifact]]s and are _never_ available for production [[deployment]]s.  It is possible to redeploy the same [[artifact]] [[version]] over and over to a "snapshot" repository.  This is the standard development target location.

### Caching Proxy Repositories
While being able to host repositories is important, it is equally important to cache all the _external_ dependencies for builds.  For the most part, these are things that we acquire from the Internet.  Keeping a copy of these prevents things like the [Leftpad](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/) and [colors.js](https://www.theverge.com/2022/1/9/22874949/developer-corrupts-open-source-libraries-projects-affected) "incidents".  A caching proxy, like [[Nexus]], keeps a copy of existing content from requested content and delivers its cached copy to prevent unnecessary re-downloading.

Essentially, a proxy repository is one that fronts some external location (the "target URL").  Queries to the proxy repository URL check the local cache for a copy of the target request.  If that target is not present, then it queries the target URL and caches a copy of the result that it acquires.  It then delivers the cached value to the requester, if available, and responds with an error if not. 

### Group Repositories
A final capability of [most] artifact repositories is to provide a location for aggregated grouping of multiple other storage locations.  Usually, a group repository is made of an ordered list of other repositories (including other group repositories), and a query for resolution against the group goes down the list until the request is satisfied or the group repo runs out of other repositories to query.

The group resolution mechanism works someting like this:

1. A query is made to some **group** repo URL
2. That group repository looks in it's local cache to see if it has the artifact in question
3. If not, then it tries each of it's candidate repository URLs to see if they can supply the artifact in question.
4. If the current candidate repo supplies the artifact, the group repo caches it _and stops iterating on its list of candidates_ (i.e. once it finds an answer, it caches it and stops looking for more answers).
5. If the group repo has the artifact cached, it responds to the original request with its cache
6. If it does not have the artifact cached, it responds with an "unavailable" or "not found" error (almost always a `404`)

#### Group Overrides

Occasionally it will be the case that a specifically _identified_ [[version]] of a publicly acquired [[artifact]] is needed, but that version is somehow flawed.  If it is possible to somehow acquire an accetable copy of the [[artifact]], either from some other repo or by forking and building it onesself, then an "override" repo can be useful.

An override repo is simply a [[#Release|hosted release]] repo that is put at the head of the ordered list of candidate repository URLs in some [[#Group Repositories|group]].

### Examples of Artifact Repository Usage

#### Container Registry

Alice uses [Packer](https://packer.io) to [[build]] a [Docker](https://www.docker.com/) container.  She namespaces it `alicecontainer/emulsified` and gives it a version of `1.0.0`. Since Alice has access to an [[artifact repository]] at %3Chttps://myartifactrepo.org/dockerregistry%3E, as part of her Packer `.json` file Alice performs a `push` action to that repository.  There is now an artifact in that repository called `alicecontainer/emulsified:1.0.0`

Bob wants to use Alice's container as a basis for his `Dockerfile` build. He points his registry endpoint to  <https://myartifactrepo.org/dockerregistry> and bases his build on `alicecontainer/emulsified:1.0.0`.  Docker then tries to fetch the container during his build, allowing Bob to layer his filesystem over the `emulsified` container's filesystem.

#### Python Package Repo

Carole is building a Python library for distribution to the other members of SampleCo, where she works.  There is an [[artifact repository]] for Python packages at <https://artifacts.sampleco.com/python>.  She builds and deploys her package as `carolesmith/mylib` version `2.3.2` to that repository.  Now it is available to other developers who have access to that repository inside SampleCo simply by indicating `carolesmith/mylib 2.3.2` in a Python `requirements.txt` file.

#### General Artifact Availability

Dave has a file full of private information that he needs to distribute to a specific group of people.  Dave, who also works at SampleCo, knows that there is an ACL-restricted generic repository at  <https://artifacts.sampleco.com/secretsauce> .  So Dave produces a file called `thesauce.zip` which he uploads to that repository with a version of `dave/sauce 1.0.0`.  He then builds a group `Sauceaholics` that has access to that repository (which is very different from general internal availability at SampleCo) and adds all the consumers that need access to the sauce `.zip` file to that group.  Those users can then go fetch the appropriate file, and if Dave uploads a newer version `dave/sauce 1.0.1` they can also obtain that one.

Ellen _also_ needs to send a file to the members of `Sauceaholics`.  She uploads her file as `ellen/notsauce 1.0.0` to that repository and now all members of `Sauceaholics` can also fetch Ellen's artifact.>)

---